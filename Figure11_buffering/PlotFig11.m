
%% Script to plot Figure 11

% ------------------------------------------------------------------------%
% Copyright 2017 Regents of the University of California

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions
% are met:

% 1. Redistributions of source code must retain the above copyright
%    notice, this list of conditions and the following disclaimer.

% 2. Redistributions in binary form must reproduce the above copyright
%    notice, this list of conditions and the following disclaimer in the
%    documentation and/or other materials provided with the distribution.

% 3. Neither the name of the copyright holder nor the names of its
%    contributors may be used to endorse or promote products derived
%    from this software without specific prior written permission.

% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
% "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
% LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
% A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
% HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
% SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
% LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
% DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
% THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
% (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
% OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
% ------------------------------------------------------------------------%


rerunsims=0;
% 1 - rerun the simulations to generate data, then plot
% 0 - load previously saved data, then plot


%% Run simulation / load data

path=[pwd '\RotorNet_model\'];

if rerunsims==1
    cd RotorNet_model
    workers=31; % number of parallel workers, set equal to number of logical processors
    Main_RotorLB_256_buffers(workers); % warning: this function takes a long time to run, set workers to >= 31
    cd ..
end;

% NOTE: this .mat file is generated by running the function: [pwd '\RotorNet_model\Main_RotorLB_256_buffers.m']
load([path 'RotorLB_N=256_31_aggqueuestats.mat']);

% cat all queue stats:
[~,s]=size(allqueue{1});
allqueuecat=zeros(NN,s*Nreal);
for a=1:Nreal
    for b=1:NN
        allqueuecat(b,1+(a-1)*s:a*s)=allqueue{a}(b,:);
    end;
end;
avqueue=zeros(1,NN);
for a=1:NN
    avqueue(a)=mean(allqueuecat(a,:));
end;


%% endpoint buffer requirement plot:

sclfactor=3.2e12/8*180e-6/1e6; % (MB) per 6.4 Tb/s ToR, 180 us slot time

F=16; % fontsize
LW=2; % linewidth

figure;
hold on;
h2=plot(Nflows0/Nflows0(end),sclfactor*(sum(maxqueue,2)/Nreal),'-','color',[.75 0 0],'linewidth',LW,'marker','v','markersize',8);
for a=1:NN
    plot(Nflows0(a)/Nflows0(end)*[1 1],sclfactor*[max(maxqueue(a,:)) min(maxqueue(a,:))],'color',[.75 0 0],'linewidth',LW);
    plot(Nflows0(a)/Nflows0(end)*[1 1]+[-.01 .01],sclfactor*max(maxqueue(a,:))*[1 1],'color',[.75 0 0],'linewidth',LW);
    plot(Nflows0(a)/Nflows0(end)*[1 1]+[-.01 .01],sclfactor*min(maxqueue(a,:))*[1 1],'color',[.75 0 0],'linewidth',LW);
end;

h3=plot((Nflows0)/(Nflows0(end)),sclfactor*avqueue,'-','color',[0 0 0],'linewidth',LW,'marker','o','markersize',10);
grid on;
box on;
xlim([0 1]);
set(gca,'fontsize',F);
xlabel('Traffic density');
ylabel('Per rack buffer (MB)');

hleg=legend([h2 h3],'Worst cases observed','Average');
hleg.FontSize=F;

ax=gca;

ax.XTick=(0:.25:1);
ylim([0 450]);

ax.XColor=[0 0 0];
ax.YColor=[0 0 0];
ax.GridColor=[0 0 0];
ax.MinorGridColor=[0 0 0];
ax.GridAlpha=.2;

outerpos = ax.OuterPosition;
ti = ax.TightInset; 
left = outerpos(1) + ti(1);
bottom = outerpos(2) + ti(2);
ax_width = outerpos(3) - ti(1) - ti(3);
ax_height = outerpos(4) - ti(2) - ti(4);
ax.Position = [left bottom ax_width ax_height];

fig = gcf;
fig.PaperPositionMode = 'auto';
fig_pos = fig.PaperPosition;
fig.PaperSize = [fig_pos(3) fig_pos(4)];

%% CDF

figure;
hold on;
h=cdfplot(sclfactor*allqueuecat(12,:)); % for 256
h.LineWidth=LW;
y=get(h,'ydata');
x=get(h,'xdata');
vals=[.999 .9999 1];
c=[.33*[1 0 0]; ...
    .66*[1 0 0]; ...
    1*[1 0 0]];
for a=1:max(size(vals))
    ind=find(y>=vals(a),1);
    hv(a)=plot(x(ind)*[1 1],[0 1],'--k','linewidth',LW,'color',c(a,:));
end;
title('');
xlabel('Per rack buffer (MB)');
ylabel('CDF');
box on;
ax=gca;
ax.FontSize=F;
ax.YTick=(0:.25:1);

xlim([0 450]);

hw=plot(0,0,'w');
hleg=legend([hw hv],'','0.1%','0.01%','0%');
hleg.Location='northwest';

ha=annotation('textbox','string','Loss:');
ha.LineStyle='none';
ha.FontSize=F;
ha.Position=[.18 .74 .3 .2];


ax.XColor=[0 0 0];
ax.YColor=[0 0 0];
ax.GridColor=[0 0 0];
ax.MinorGridColor=[0 0 0];
ax.GridAlpha=.2;

outerpos = ax.OuterPosition;
ti = ax.TightInset; 
left = outerpos(1) + ti(1);
bottom = outerpos(2) + ti(2);
ax_width = outerpos(3) - ti(1) - ti(3);
ax_height = outerpos(4) - ti(2) - ti(4);
ax.Position = [left bottom ax_width-.01 ax_height];

fig = gcf;
fig.PaperPositionMode = 'auto';
fig_pos = fig.PaperPosition;
fig.PaperSize = [fig_pos(3) fig_pos(4)];


%%






